1. SQL Constrainst sand Views

Relational Schema

Person(-personal_nr-, name, tel, email)
    unqiue(tel)
    unique(email)
Organisation(-org_nr-, name, address, director, value)
    director -> Person.personal_nr
    unique(director)
Loan(-id-, client, type, amount, binding, bdate, interest)
    client -> Person.personal_nr

1.a

CREATE TABLE Persons (
    personal_nr TEXT PRIMARY KEY
    CHECK(personal_nr LIKE 'P__________') //No info on constraints for this from DS but i think this is reasonable
    name TEXT NOT NULL
    tel TEXT NOT NULL UNIQUE //Not required by DS but i think its good for safety reasons
    email TEXT NOT NULL UNIQUE //Same for this
);

CREATE TABLE Organisations (
    org_nr TEXT PRIMARY KEY
    CHECK(org_nr LIKE 'O__________')
    name TEXT NOT NULL
    address TEXT NOT NULL //Could be unqiue but would make it though for companies in the same building
    director TEXT NOT NULL UNIQUE
    FOREGIN KEY (director) REFERENCES Persons(personal_nr)
    value INT NOT NULL //Should not be strictly posetive! Think of companies with excessive debts.
);

CREATE TABLE Loans (
    id TEXT PRIMARY KEY
    CHECK(id LIKE CONCAT('L',client,'__________'))
    client TEXT NOT NULL
    FOREIGN KEY (client) REFERENCES Persons(personal_nr)
    type TEXT NOT NULL
    CHECK(type IN ('private','org'))
    amount INT NOT NULL
    CHECK(amount > 0)
    binding INT NOT NULL
    CHECK(binding IN (1,2,3,5))
    bdate DATE NOT NULL
    interest FLOAT NOT NULL //Negative rent exists! You could maybe cap this but i dont really se why since super high rent can exist in unstable economies
);

1.b

CREATE VIEW ActiveLoans AS (
    SELECT * FROM Loans 
    WHERE CURRENT_DATE =< Loans.bdate + Loans.binding * 365
);

1.c

CREATE VIEW EndingLoans AS (
    WITH AboutToExpire AS (
        SELECT *, bdate + binding * 365 - CURRENT_DATE as daysToExpire FROM ActiveLoans 
        WHERE CURRENT_DATE >= (Loans.bdate + Loans.binding * 365) - 30
    )
    (SELECT name, email, daysToExpire
    FROM Persons JOIN AboutToExpire ON personal_nr = client
    WHERE type = "private")
    UNION
    (SELECT name, email, daysToExpire
    FROM Organisations JOIN AboutToExpire ON director = client
    WHERE type = "org")
);

1.d

WITH LoanKindIsBoth AS (
    (SELECT client, 'both' AS kind FROM ActiveLoans
    WHERE type = 'org')
        INTERSECT
    (SELECT client, 'both' AS kind FROM ActiveLoans
    WHERE type = 'private')
);

WITH LoanKindIsOnlyPrivate AS (
    (SELECT client, 'private' AS kind FROM ActiveLoans
    WHERE type = 'private')
        EXCEPT
    (SELECT client, 'private' AS kind FROM LoanKindIsBoth)
);

WITH LoanKindIsOnlyOrg AS (
    (SELECT client, 'org' AS kind FROM ActiveLoans
    WHERE type = 'org')
        EXCEPT
    (SELECT client, 'org' AS kind FROM LoanKindIsBoth)
);

WITH LoanKindIsNone AS (
    (SELECT personal_nr AS client, 'none' AS kind FROM Persons)
        EXCEPT 
    (SELECT client, 'none' FROM ActiveLoans)
);

SELECT personal_nr, name, kind
FROM Persons 
JOIN LoanKindIsNone ON (personal_nr = client)
JOIN LoanKindIsBoth ON (personal_nr = client)
JOIN LoanKindIsOnlyOrg ON (personal_nr = client)
JOIN LoanKindIsOnlyPrivate ON (personal_nr = client)
ORDER BY personal_nr;

2.a

SELECT DISTINCT org_nr, name FROM Organisations
JOIN ActiveLoans ON director = client
WHERE type = 'org' AND (amount >= value * 3)
ORDER BY org_nr DESC;

τ- org_nr(δ(π org_nr, name (σ type = 'org'∧ amount > value * 3(Organisations ⨝ director = client ActiveLoans))))

2.b

SELECT personal_nr, name, SUM(amount) AS total FROM Persons
JOIN ActiveLoans ON personal_nr = client
GROUP BY personal_nr
HAVING SUM(amount) > 10000000
ORDER BY total

τ total(δ total > 10000000(γ personal_nr, name, SUM(amount)→total (Persons ⨝ personal_nr = client Persons)))

3.a

I would create an AFFTER UPDATE trigger on the table Organisations that changes the
client in active loans after the Organisations director has been updated. The trigger
would use a function that checks if NEW.director isnt the same as OLD.director
CREATE FUNCTION <name>() RETURNS TRIGGER AS $<name>$

3.b

CREATE VIEW MonthlyPayments AS (
    SELECT id, email, ((amount * interest)/12) AS monthlyPay
    FROM ActiveLoans
    JOIN Persons ON client = personal_nr
    WHERE amount <= 10000000
        UNION 
    SELECT client, ((amount * (interest-0.05))/12) AS monthlyPay
    FROM ActiveLoans
    JOIN Persons ON client = personal_nr
    WHERE amount > 10000000 AND type = 'org'
)

3.c 

We can add a table with IS A relationship to persons, so if we add
the table

CREATE TABLE Directors (
    director_nr TEXT PRIMARY KEY
    FOREIGN KEY director_nr REFERENCES Persons.personal_nr
)

Then make Organisations reference Directors.directorPnr as a 
foreign key instead of referenceing Persons.personal_nr

You can also make a FUNCTION RETURNS TRIGGER that checks if the 
person being entered as a loan taker is the director of a company
And add the trigger BEFORE INSERT

4.
Check jpg with same name as this document

5.a

R(attachment, blocked_user, channel_id, channel_name,
  message_id, reacting_user, reaction, text, time, timeout,
  user)

FDs

1. user, message_id -> channel_id, channel_name, text, time
2. channel_id -> channel_name
3. channel_name -> channel_id
4. user, blocked_user -> timeout

We decompose R with the fd 1
R1(user, message_id, channel_id, channel_name, text, time)
R2(user, message_id, reacting_user, reaction, timeout, blocked_user)

We decompose R1 with fd 2
R11(user, message_id, channel_id, time, text)
R12(channel_id, channel_name)

We decompose R2 with fd 4
R21(user, message_id, reacting_user, reacting_user, blocked_user)
R22(user, blocked_user, timeout)

Finishing decompositions

R11(-user-, -message_id-, channel_id, time, text)
    channel_id->R12.channel_id

R12(-channel_id-, channel_name)

R21(-user-, -message_id-, reacting_user, reacting_user, blocked_user)
    (user, message_id)->R11.(user, message_id)
    (user, blocked_user)->R22.(user, blocked_user)

R22(user, blocked_user, timeout)

5.b

MVDs

1. user, message_id ->> attachment
2. user, message_id ->> reaction, reacting_user

Breakdown R21 with MVD 1

R211(-user-,-message_id-, attachment)

R212(-user-,-message_id-, reaction, reacting_user)

6.a

{
    "type": "array",
    "items" :
    {
        "type" : "object
        "properties" {
            "id" : {
                "type" : "integer"
            },
            "status" : {
                "type" : "string",
                "status" : {"enum" : ["reported", "active", "resolved"] }
            },
            "reportedBy" : {
                "type": "object"
                "properties" : {
                    "name" : {"type" : "string"},
                    "email" : {"type" : "string"}
                }
                "required" : {
                    "name",
                    "email"
                }
            }
            "handlers" : {
                "type": "array",
                "items" : {
                    "type": "object"
                    "properties" : {
                        "name" : {"type" : "string"},
                        "email" : {"type" : "string"}
                    }
                    "required" : {
                        "name",
                        "email"
                    }
                }
            }
        }
        "required": [
        "id",
        "status",
        "reportedBy"
        ]
    }
    
}

    
